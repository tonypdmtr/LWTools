/*
cmt.c

Copyright Â© 2010 William Astle

This file is part of LWTOOLS.

LWTOOLS is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along with
this program. If not, see <http://www.gnu.org/licenses/>.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include <lw_alloc.h>
#include <lw_string.h>

#include "lwasm.h"
#include "instab.h"

line_t *list_one_line(asmstate_t *, FILE *, line_t *);
static line_t* cmt_one_line(asmstate_t *, FILE *, line_t *);
static int get_addr(asmstate_t *, line_t *);
static int calc_crc(line_t *);
static uint32_t crc32(const void *, size_t);

/*
Generate CMT file for MAME
*/
void do_cmt(asmstate_t *as)
{
	if (!(as -> flags & FLAG_CMT)) return;

	FILE* of = NULL;

	if (as -> cmt_file)
	{
		if (strcmp(as -> cmt_file, "-") == 0)
		{
			of = stdout;
		}
		else
			of = fopen(as -> cmt_file, "w+");
	}
	else
		of = stdout;

	if (!of)
	{
		fprintf(stderr, "Cannot open cmt file; not generated\n");
		return;
	}

	fputs("<?xml version=\"1.0\"?>\n", of);
	fputs("<!-- autogenerated by " PACKAGE_STRING "; comments and unknown tags will be stripped -->\n", of);
	fputs("<mamecommentfile version=\"1\">\n", of);
	if (as -> cmt_system) fprintf(of, "<system name=\"%s\">\n", as -> cmt_system);
	else fputs("<system name=\"coco3\">\n", of);
	fputs("<cpu tag=\":maincpu\">\n", of);

	line_t* line = as -> line_head;
	if (line)
	{
		int comment_address;
		int comment_tag_open = 0;
		int addr = get_addr(as, line);

		while (1)
		{
			if (comment_tag_open && comment_address != addr)
			{
				fputs("</comment>\n", of);
				comment_tag_open = 0;
			}

			if (!comment_tag_open)
			{
				comment_address = get_addr(as, line);
				fprintf(of, "<comment address=\"%d\" color=\"16711680\" crc=\"%08X\">\n", comment_address, calc_crc(line));
				comment_tag_open = 1;
			}

			line = cmt_one_line(as, of, line);
			if (!line) break;

			addr = get_addr(as, line);
		}

		if (comment_tag_open) fputs("</comment>\n", of);
	}

	fputs("</cpu>\n", of);
	fputs("</system>\n", of);
	fputs("</mamecommentfile>\n", of);

	if (of && of != stdout)
		fclose(of);
}

static line_t* cmt_one_line(asmstate_t *as, FILE *of, line_t *line)
{
	fpos_t pos;
	char buf[1024];

	fgetpos(of, &pos);

	line = list_one_line(as, of, line);

	fsetpos(of, &pos);
	char* result = fgets(buf, 1024, of);
	if (!result)
	{
		fprintf(stderr, "error processing cmt file");
		exit(1);
	}

	fsetpos(of, &pos);
	char* ch = buf + 21 + 21; /* MAME comment window is narrow so skip output bytes and filename */

	while (*ch)
	{
		switch (*ch)
		{
		case '&':
			fputs("&amp;", of);
			break;

		case '<':
			fputs("&lt;", of);
			break;

		case '>':
			fputs("&gt;", of);
			break;

		default:
			fputc(*ch, of);
		}

		ch++;
	}

	return line;
}

/* this looks overcomplicated, but we'll need it later for OS-9 and MMU support */
static int get_addr(asmstate_t *as, line_t *line)
{
	int addr = line -> addr -> value;

	if ((line -> len < 1 && line -> dlen < 1) && (line -> symset == 1 || line -> sym == NULL))
	{
		if (line -> soff >= 0)
		{
			// addr = cl->soff & 0xffff;
		}
		else if (line -> dshow >= 0)
		{
			// addr = cl->dshow & 0xff;
		}
		else if (line -> dptr)
		{
			lw_expr_t te;
			te = lw_expr_copy(line -> dptr -> value);
			as -> exportcheck = 1;
			as -> csect = line -> csect;
			lwasm_reduce_expr(as, te);
			as -> exportcheck = 0;
			if (lw_expr_istype(te, lw_expr_type_int))
			{
				addr = lw_expr_intval(te) & 0xffff;
			}
			else
			{
				// addr = 0;
			}
			lw_expr_destroy(te);
		}
	}

	return addr;
}

static int calc_crc(line_t* line)
{
	if (line -> outputl <= 0) return 0;
	return crc32(line -> output, line -> outputl);
}

/* Simple public domain implementation of the standard CRC32 checksum. */

static uint32_t crc32_for_byte(uint32_t r)
{
	for (int j = 0; j < 8; ++j)
		r = (r & 1 ? 0 : (uint32_t)0xEDB88320L) ^ r >> 1;
	return r ^ (uint32_t)0xFF000000L;
}

static uint32_t crc32(const void *data, size_t n_bytes)
{
	uint32_t crc = 0;
	static uint32_t table[0x100];

	if (!*table)
		for (size_t i = 0; i < 0x100; ++i)
			table[i] = crc32_for_byte(i);
	for (size_t i = 0; i < n_bytes; ++i)
		crc = table[(uint8_t)crc ^ ((uint8_t*)data)[i]] ^ crc >> 8;

	return crc;
}
